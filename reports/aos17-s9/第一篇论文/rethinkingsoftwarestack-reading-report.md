## What the problems the paper mentioned?

今天大多数主流的操作系统设计方案保持不变,即使硬件和软件已经进化。操作系统建立了几乎所有软件栈的基础，所以其中设计的不足会对当前系统产生普遍的影响。Singularity项目根据编程语言和验证工具的发展重新审查了这些设计选择,吸收了三个关键性的架构特征：

- 保护程序和系统服务的软件隔离过程：为防止外部干扰的程序提供了一个执行环境。
- 用于通信的基于合同的通道：可以在过程之间进行快速、可验证的基于消息的通信。
- 用于验证系统属性的基于清单的程序：定义在软件隔离的进程中运行的代码，并指定其可验证的行为属性。

Singularity项目找出缺陷的领域:

- 普遍的安全漏洞
- 应用程序之间意外的交互
- 由错误扩展,插件和驱动程序导致的故障
- 以及可察觉的鲁棒性缺乏

如果从头开始设计,主要目标是提高可靠性和可信度,软件平台将是什么样子？拥护三种策略：

- 安全编程语言的普遍使用消除了许多可预防的缺陷,例如缓冲区溢出
- 使用合理的程序验证工具将进一步保证程序员对整个类的设计错误在开发周期的早期从系统中移除
- 改进的系统架构将会停止运行时错误在明确定义的边界内传播,使得更容易实现鲁棒性和正确的系统行为

指导哲学是化繁为简,分别为执行，通信和系统验证提供基本支持，并且是建立可靠地，可验证的系统。

## Summary of major innovations

### SIP 

​        SIP 利用现代编程语言的类型和内存安全性，而不是内存管理硬件完成隔离，大大降低了安全代码的成本。通过静态验证和运行时检查的组合，Singularity验证SIP中的用户代码不能访问SIP外部的内存区域。使用由软件而不是硬件提供的过程隔离，多个SIP可以驻留在单个物理或虚拟地址空间中。在最简单的Singularity 系统中，内核和所有SIP共享单个内核模式地址空间，可以通过将SIP分层到多个地址空间来构建更丰富的系统。

​        通过列表展现出与硬件保护的进程相比，SIP之间的通信引起的开销更低，并且创建和销毁成本低，与硬件保护的进程不同，可以创建SIP而不创建页表或刷新TLB。SIP之间的上下文切换也具有非常低的开销，因为TLB和虚拟寻址的高速缓存不需要被刷新，在终止时，SIP的资源可以被有效的回收并且其存储器页面被回收而不涉及垃圾收集。

​        低成本使得将SIP用作细粒度隔离和扩展机制来替代硬件保护进程和未保护的动态代码加载等常规机制是实用的，因此,Singularity 仅需要一个错误恢复模型，一个通信机制，一个安全架构和一个编程模型，而不是当前系统中使用的部分冗余机制和策略。

​        SIP与其它操作系统中的进程共享许多属性，每个用户程序的执行发生在SIP的上下文中，与SIP相关联的是包含代码和数据的一组存储器页面。SIP包含一个或多个执行线程。SIP采用安全身份执行，并具有相关的OS安全属性。而且SIP提供信息隐藏和故障隔离。 

​	SIP不共享数据，所有通信通过被称为信道的消息传递管道上进行信息交换实现，SIP是封闭的对象空间，一个SIP中的对象可以不被任何其它SIP修改或直接访问，SIP之间的通信通过传递消息中的独占所有权来进行。线性类型系统和被称为交换堆的特殊存储区域允许轻松交换大量的数据，但是不能共享。因此，SIP自主执行，每个SIP都有自己的数据布局，运行时系统和垃圾收集器。Singularity增加了可静态验证合同的严格性。合同用于在给定类型的所有信道上的通信的消息和协议。SIP通过内核的应用程序二进制接口(ABI)调用原始功能，例如发送和接受消息。Singularity ABI具有包含完全声明性版本控制信息的严格设计，它提供对内存，执行和通信等最基本的计算方面的安全本地访问，并且排除语义上不明确的构造，例如ioctl.

​	SIP是密封的代码空间，不同与其它SIP共享可写内存,SIP的代码在执行时被密封，SIP通过软件验证而不是硬件保护来隔离。作为密封进程，SIP不能自动地加载和生成代码，密封过程具有强制操作系统和应用程序的通用扩展机制：扩展代码在新进程中执行，与其主机的SIP不同。密封技术提供了很多优点：

* 增加了程序分析工具静态检测缺陷的能力
* 支持更强的安全机制。例如通过其代码内容识别进程。
* 还可以消除运行时在执行环境中复制OS样式访问控制的需要。

​        SIP的一个关键实验就是使用SIP构建整个操作系统，并证明所产生的的系统比传统系统更可靠，到目前为止结果是有希望的，SIP成本低，足以满足每个SIP开发者和团队的特定软件开发粒度，并且足够为异常行为提供故障停止边界。

### 基于合同的信道：

Singularity的SIP之间的所有通信流都是通过基于合同的信道。信道是恰好具有两个终端的双向消息管道，通道提供无损的、有序的消息队列。从语义上讲，每个端点都有一个接收队列，在一端发送会在另一端的接收队列上排队一个消息。通道端点每次只属于一个线程，只有端点的拥有线程可以从其接收队列中出队消息或向其对等体发送消息。

通过信道的通信由信道合同描述，通道的两端在合同中不对称。一个端点是导入段(Imp),另一个端点是导出端(Exp)，在Sing#语言中，端点通过类型C.Imp和C.Exp区分，其中C是管理交互的信道约定。

信道合同以Sing#语言声明,合同由消息声明和一组命名的协议状态组成。消息声明陈述每个消息的参数的数量和类型以及可选的消息方向，在状态机中指定导致每个状态变成其它状态的可能消息序列。消息序列由消息标记和消息方向组成，如果消息声明已包含方向，则消息方向标记不是严格必须的，但是这些符号使状态机更易读。

信道支持SIP之间的高效且可分析的通信，当结合对线性类型的支持时，Singularity允许SIP访问信道之间的大量数据的0拷贝交换，此外，Sing#编译器可以静态的验证在通道上的发送和接收操作不以错误的协议状态应用。单独的合同验证器可以读取程序的字节代码并且静态的验证在程序内使用了哪些合同，并且验证改代码是否符合合同协议中描述的状态机。

经验表明，信道合同是防止和检测错误的宝贵工具。作者举了个例子，合同一致性验证器上线之后立刻发现了一个存在了一年的问题，几秒钟变解决了这一问题，并确定触发错误的确切情况。

信道合同在交互组件之间提供了清晰地关注点，有助于在高层次了解系统架构，静态检查有助于程序员避免运行时消息未被理解的错误。此外，通道的运行时语义限制了仅在接收时观察到的失败，因此提供了在不方便进行发送操作时处理错误的条件。

### 基于清单的程序(MBP)

没有代码被允许在没有清单的Singularity系统上运行。为了开始运行，用户调用清单，而不是像在其它系统中一样执行可执行文件。

清单描述了MBP的代码资源，其所需的系统资源，其期望的能力，以及对其他程序的依赖性。当在系统上安装MBP时，清单用于识别和验证MBP代码满足所有所需的安全属性，以确保可以满足所有MBP的系统依赖性，并且防止先前安装的MBP干扰。在执行之前，清单用于发现影响MBP的配置参数和对这些配置参数的限制，当MBP被调用时，清单引导代码到用于执行的SIP的布置，新SIP和其它SIP之间的信道连接，以及通过SIP授予对系统资源的访问。

清单不仅仅是对SIP代码内容的列举或程序的描述，它是对MBP预期行为的机器可检查的，声明性表达式。清单的主要目的是允许静态和动态验证MBP的属性。例如，设备驱动程序的清单提供足够的信息以允许安装时验证该驱动程序将不会访问由先前安装的设备驱动程序使用的硬件。而且通过Singularity验证的MBP属性包括类型和存储器安全性，缺少特权模式指令，符合信道合同，仅适用声明的信道合同，以及正确的版本化ABI的使用。

MBP的代码可以作为清单的内联元素包含或者在单独的文件中提供，解释的脚本语言（如Singularity shell语言）可以轻松地包含为清单的内联元素。 另一方面，大的编译应用程序可能由许多二进制文件组成，一些是MBP独有的，一些与其他MBP共享，并且与MBP的清单分开存储在一个储存库中。

Singularity的常见MBP清单可以通过内联或者在其他文件中通过元数据进行扩展，以允许复杂属性的验证， 例如，基本清单不足以验证MBP是类型安全的或者仅使用通道合同的特定子集。 验证编译代码的安全性需要MBP二进制文件中的附加元数据。

为了促进尽可能多的运行时属性的静态验证， Singularity MAP的代码作为编译的微软中间语言(MSIL)二进制文件被递送到系统。 Singularity使用具有特定特征的标准MSIL格式，通过MSIL元数据方式扩展，除了少数例外，操作系统在安装时将MSIL编译为本地指令集。 通过清单来简化JIT编译与安装时编译，清单声明了从MBP创建的SIP的所有可执行MSIL代码。

Singularity中的每个组件都由清单描述，包括内核、设备驱动程序和用户应用程序，MBP有助于创建具有可验性的硬件访问属性与自我描述的设备驱动程序。Singularity使用清单特征将命令行处理移出几乎所有应用程序，并将其集中在shall程序中。虽然还没有证明，但是作者认为MBP将在降低系统管理成本方面发挥作用。

### Kernel

内核提供软件隔离进程，基于合同信道与基于清单的程序的基本抽象，并且在竞争程序和系统硬件复杂性抽象中起到重要作用，对每个SIP，内核为线程提供纯净的执行环境，内存以及通过信道访问其它MBP. 内核使用类型安全的，基于垃圾收集的语言实现，享有安全，高效的优点。内核是一个微核，所有的设备驱动程序，网络协议，文件系统和用户可替换服务在内核以外的SIP中执行。保留在内核中的功能包括调度，中介特权访问硬件资源，管理系统内存，管理线程和线程堆栈，以及创建和销毁SIP和信道。

### ABI

SIP通过ABI访问原始内核设施，ABI遵循最小特权原则。默认，SIP只能操纵自己的状态，停止和启动子SIP。ABI为每个SIP确保最小，安全和隔离的计算环境。SIP可以访问更高级别的系统服务，例如访问文件或发送和接受网络数据包的能力，这些通过信道实现，而不是ABI功能。信道终端在进程启动时出现，由基于清单的配置制定，或通过现有通道传递消息，SIP能访问文件必须是从另一个SIP中接收到文件系统的终端。

通过设计，ABI区分用于从较高级服务访问原始过程实现本地操作的机制。这种区别支持使用信道终端作为能力和信道属性进行动态的验证。静态分析工具可以使用键入信息来确定代码访问的功能。例如，静态分析工具可以确定应用插件不能启动分布式拒绝服务攻击，因为它不包含使用网络信道合同的代码。

内核ABI是强版本化的。每个MBP的清单显示标志其需要的ABI版本。在语言级别，程序代码是针对特定的ABI接口编译的装配在明确命名版本的版本空间上。Singularity可以导出其ABI的多个版本，提供清晰的路径向后兼容。

ABI保持系统范围的状态隔离不变：一个进程不能通过ABI函数直接改变另一个进程的状态，对象引用不能通过ABI传递到内核或另一个SIP，因此，内核和每个进程的垃圾收集器独立执行。ABI调用只影响调用进程的状态，例如：不能跨SIP边界访问进程同步对象(例如互斥体)，状态隔离确保了Singularity进程对其状态的唯一控制。

跨越SIP和内核代码之间的ABI边界可能是非常有效的，因为SIP依赖于软件隔离而不是硬件保护，最好的情况是在与内核相同的地址空间中以内核硬件特权级别运行的SIP(x86架构上的ring0).然而，ABI调用比函数调用更昂贵，因为它必须标记SIP的垃圾收集空间和内核的垃圾收集空间之间的过渡。

### 特权代码

在任何操作系统中，系统完整性受到特权指令的保护，例如：加载新的页表可以反转硬件保护过程存储器，因此操作系统将保护对加载页表的代码路径访问。在依赖于硬件保护的操作系统中，包含特权指令的函数必须在内核中执行，与用户代码在不同的特权级别上运行。

SIP赋予在设置特权指令时更大的灵活性,因为类型和内存安全性确保了函数的执行完整性。Singularity可以将特权指令和安全检查放置在SIP内部运行的可信函数中。例如，用于访问I/O硬件的特权指令在安装时可以安全的并入到设备驱动程序中，其它ABI功能也可以在安装时内嵌到SIP代码中。Singularity利用这种这种安全的内联去优化信道通信以及语言运行和垃圾收集的性能。

### 句柄表

虽然禁止交叉ABI对象引用，但是在内核中对SIP代码中的抽象对象命名是必要的，例如互斥变量和线程。抽象内核对象通过引用内核句柄表中插槽的强类型、不透明句柄暴露给SIP。在内核中，句柄表槽包含对文本内核对象的引用，强类型防止SIP代码更改或伪造非零句柄，此外，只有当SIP终止时，才会回收句柄表中的槽，以防止SIP释放互斥体，保留其句柄，以及使用它操作另一个SIP的对象。 Singularity重用了SIP中的表条目，因为这种情况下保留句柄只能影响非法的SIP。

### 内存管理

在大多数Singularity系统中,内核和所有的SIP都被软件隔离在单独的地址空间中来保护，地址空间在逻辑上被划分为内核对象空间，每个SIP的对象空间以及用于通道数据通信的交换堆。一个普遍的设计决策是内存独立不变性：指针必须指向SIP自己的内存或者交换堆中SIP拥有的内存，没有SIP可以有指针指向另一个SIP对象的对象，这个不变性确保每个SIP可以无需和其它SIP合作而被垃圾收集和终止。

SIP通过对内核页面管理器的ABI调用获得内存,将会返回新的，未共享的页给SIP。这些页面不需要和SIP之前分配的内存页相邻，因为垃圾收集器不需要连续的内存，尽管可以为大对象或数组分配连续页面的块。除了用于SIP代码和堆数据的内存以外，SIP还具有每个线程的堆栈和对交换堆的访问。

### 交换堆

在SIP之间传递的所有数据必须驻留在交换堆中，SIP拥有指向自己的堆和交换堆的指针，交换堆只保存指向自己的指针，在系统执行期间，交换堆中的每个存储器块至多被一个SIP可访问。注意，SIP可能将悬挂指针保存到交换堆(指向不在属于SIP的块的指针)中，静态验证确保SIP永远不会通过悬挂指针访问内存。

要启用此属性的静态验证，我们强制执行更强的属性(线性属性)，保证SIP在执行的任何点处具有至多一个指向块的指针。块的所有权只能通过在信道中发送的消息来转移到另一个SIP上，Singularity 确保SIP在消息中发送过它之后不会在访问该块。

事实上，交换堆中的每个块可以由单个线程在任何时间访问，这也提供了有效的互斥保证。此外，块释放被静态实施。在进程突然终止时，通过引用计数来恢复交换堆中的块，记录块所有权以便SIP终止时可以释放所有相关块。

### 线程

内核和SIP是多线程的，所有线程都是内核线程，在内核调度时可见，并协调阻塞操作，在大多数Singularity 系统中，内核线程上下文切换的性能更接近用户线程的预期性能，因为对于在内核的地址空间和其硬件特权级别上运行的SIP不需要保护模式转换。

#### 链栈

Singularity使用链栈来减少线程内存开销,这些堆栈通过添加非连续的4K以上的段来满足增长需求,Singularity编译器执行静态过程间分析以优化溢出测试的布局。在函数调用时，如果栈空间不足，SIP代码调用一个ABI,会分配一个新的栈段并且初始化第一段栈帧以调用段未链接程序。这将在栈帧被弹出时释放该段，对于在x86上以环0运行的SIP，当处理器切换到断堆栈之前，当前堆栈段必须始终为处理器保留足够的空间以保存中断或异常帧。

#### 调度器

针对大量频繁通信的线程做了优化，调度程序维护两个可运行线程的列表，一个是未阻塞列表，用来维护状态为Runnable的线程，另一个是抢占列表，用来维护被抢占的线程。当选择下一个线程运行时，调度程序从未阻塞列表中按照FIFO顺序移除一个线程运行，当未阻塞列表为空时，从抢占列表中按照FIFO顺序移除一个线程运行。当调度定时器发生中断时，所有未阻塞列表中的线程移动到抢占列表的末尾，前面是定时器触发时运行的线程。然后，未阻塞列表中的第一个线程被调度时，调度定时器复位。

这两个列表调度策略有利于由消息唤醒的线程，只需执行少量工作，向其他SIP发送一个或多个消息，然后阻塞等待消息。这是线程运行消息处理循环的常见行为。为了避免硬件调度定时器的昂贵复位，来自未阻塞列表的线程继承了解除阻塞它们的线程的调度量。因为两列表的策略，量子继承允许Singularity只需394周期将一个SIP中的线程上的用户代码切换到另一个SIP上的线程。

### 垃圾收集器

内核和SIP对象空间被垃圾回收管理。经验显示没有一个垃圾回收器适合所有系统和应用代码。Singularity的架构解耦了每个SIP的垃圾收集器的算法，数据结构和执行，因此它可以被选择在没有全局协调的情况下适应SIP中的代码运行。4个方面使之成为可能

* 每个SIP都有其自己的封闭的运行环境支持
* 指针不跨越SIP或内核边界，所以垃圾回收期不需要跨空间指针
* 信道上的消息不是对象，所以内存布局的协议只对交换堆上的消息和其它数据是必须的，而且这是引用计数的。
* 内核控制内存页分配，这提供了协调资源分配的联系。

Singularity现在支持5种类型的收集器，系统代码使用同步标记压缩收集器，因为收集暂停时间特别短，每个线程都有一个隔离的自由列表，消除了在正常情况下的线程同步。垃圾回收再分配空间达到阈值时并且标记可达对象的独立收集线程执行时触发。垃圾回收时，停止所有线程扫描其堆栈，暂停时间将小于100微秒。开销高于非并发收集器，因此对应用程序一般使用非并发的标记清除回收器。

每个SIP都有自己的收集器，完全负责回收其对象空间中的对象。从收集器的角度来看，进入或离开SIP的控制线程看起来类似来自常规收集环境中的本地代码的调用或回调。因此，不同对象空间的垃圾回收器可以被调度和完全独立的运行。如果SIP使用stop-the-world收集器，那么线程被认为是相对于SIP对象空间静止，即使它由于内核调用而在内核对象空间中运行。在收集期间返回SIP时会停止。

在垃圾收集环境中，线程的堆栈包含作为收集器的潜在根的对象引用。对内核的调用也在用户线程的栈上执行，并且可以将内核指针存储在该栈中，一开始，这违反了通过创建交叉SIP指针的内存独立不变量。为了避免这个问题，限定边界在每个空间的堆栈帧之间，所以垃圾回收器看不到对其他空间的引用。在交叉空间调用时，将被调用的寄存器保存在栈上的特殊结构中，这也标记了跨空间调用。这些结构标记了属于每个对象空间的栈区域的边界。因为内核ABI中的调用不传递对象指针，所以垃圾回收器可以跳过来自其他空间的帧，这些定界符还有助于干净的终止SIP。当SIP被杀死时，它的每个线程立即被内核异常停止，这会跳过并释放进程的堆栈帧。

### 信道实现

信道终端和跨信道传输的值驻留在交换堆中，终端不能驻留在SIP的对象空间中，因为他们可能跨越通道传递。同样，信道中传递的数据不能驻留在进程中，因为会违反内存独立不变性。消息发送者通过在由消息交换协议的当前状态确定的位置处，存储指向接收端点中的消息指针来传递所有权。 然后，发送器通知调度器接收线程是否被阻塞等待接收消息。

为了在信道中实现零分配通信通道，对信道的队列大小强制限制。合同的状态转换中的每个周期包括至少一个接受和一个发送动作，这个简单的规则保证两个端点都不会因为收不到等待消息发送无限量的数据，允许在终端中静态分配队列缓冲区。

预分配终端队列和传递指针入交换堆空间天然支持多SIP子系统（例如I / O堆栈）的“零拷贝”。 例如，磁盘缓冲器和网络分组可以跨多个信道通过协议栈传送到应用SIP，而不进行复制

### 访问控制

* 应用程序是安全主体
* 一般，SIP仅与一个安全主体相关联
* 允许委托授权通过一个信道到一个现有的SIP
* SIP所有通信发生在信道上

### 编译时反射

* 动态检查现有代码和元数据(类型和成员)，以及在运行时生成新的代码和元数据
* 代价高昂，运行时反射元数据需要大量时间
* 因为可能改变代码会禁止代码优化
* 可以用来规避系统安全和信息隐藏，并且使代码复杂化

作者开发的CTR设施：

* 它允许程序员在模式匹配和模板样式中编写检查和生成代码。 
* 可以对生成的代码和元数据进行静态验证，以确保其格式良好，类型安全，并且不会违反系统安全属性。
* 避免了反射API的复杂性

### 硬件保护域

大多数操作系统通过以下两种机制实现硬件隔离：

* 进程只允许访问物理内存的某些页面
* 特权级别阻止不受信任的代码执行特权指令以操纵系统资源

Singularity通过语言安全和静态验证提供隔离。保护域是硬件实施的保护边界，可以托管一个或多个SIP，每个保护域有不同的虚拟地址空间。处理器的MMU强制执行存储器隔离。 每个域都有它自己的交换堆，用于SIP中的域之间的通信。

硬件保护不是免费的，虽然其成本是分散的，难以量化。 硬件保护的成本包括维护页表，软TLB未命中，跨处理器TLB维护，硬分页异常以及由OS代码和支持硬件保护的数据造成的附加高速缓存压力。 此外，TLB访问在许多处理器设计的关键路径上，因此可能影响处理器时钟速度和流水线深度。 硬件保护增加了对内核和进程上下文切换的调用的成本。 在具有未标记TLB的处理器（例如x86架构的大多数当前实现）中，过程上下文切换需要刷新TLB，这引起了再填充成本。

### 异构多处理

由于物理约束，与在提高处理器速度相比，在管芯上复制处理器更容易。

作者团队通过在用户内核开关上动态切换处理器来提高系统性能，以便操作系统代码在一组处理器上运行，应用程序代码在另一组上运行。 他们断言，处理器的这种动态专用化可以更好的实现指令高速缓存局部性，并且还改进了分支预测，因为处理器会根据应用和OS代码特性调整自身。他们期望这样的动态专用化会变得更有用，因为每个芯片的核的数目比每个芯片的高速缓存增加得更快。

Singularity对新的可编程I/O的处理提供了五个优点：

* SIP最大限度地减少了对I/O内核上的精细处理器功能的需求。 例如，I/O处理器不需要具有用于过程保护的存储器管理单元。
* 基于合同的信道明确定义了I/O处理器上的SIP与其他SIP之间的通信。
* Singularity的内存隔离不变不需要协处理器上的SIP和CPU之间的的共享内存(或缓存一致性)。
* 小的，局部过程ABI隔离操作可以在本地安全实施，例如存储器分配。
* Singularity以抽象MSIL格式打包基于清单的程序，可以将其转换为任何I/O处理器的指令集。 可以为系统的x86 CPU及其基于ARM的可编程网络适配器安装相同的TCP/IP二进制文件。

### 类型化汇编语言

Singularity使用Bartok编译器将MBP的MSIL代码翻译为本机机器语言代码.由于Bartok将MSIL代码编译为本地代码，它会将数据布局从MSIL的抽象数据格式转换为具体的数据格式。 这种具体格式精确地指定字段在对象中的位置，方法指针在方法表中，以及运行时类型信息驻留在哪里。具体的数据格式还指定了垃圾回收信息，诸如每个对象中的指针字段的位置。

## How about the important related works/papers?

引用了大量的相关工作来论证了Singularity操作系统设计的合理性。例如：

* 引用的论文1讨论了软件和硬件隔离之间的权衡。
* 引用的论文3讨论了硬件保护增加了对内核和进程上下文切换的调用的成本，来印证通过软件实现的优势。
* 引用的论文10指出没有一个垃圾回收器适合所有系统和应用代码，因此Singularity操作系统的SIP设计为多种垃圾回收机制的实现提供了可能性。
* 引用的论文14提供了对密封过程的折衷和优势的彻底分析。
* 引用的论文23描述了ABI遵从最小特权原则的实现
* 引用的论文25指出了MBP有助于创建具有可验性的硬件访问属性与自我描述的设备驱动程序。

## What are some intriguing aspects of the paper?

我最感兴趣的实际是它的垃圾回收机制和编译时反射，详细内容在前文已经描述，这里不重复了。主要因为这方面在Java中有很多实现，感觉在一个系统中实现这些东西，会严重影响系统的效率，而且stop-the-world去实现垃圾回收机制在该系统中可以只是在每个SIP中暂停，而不是全局，感觉这点很有前景。

## How to test/compare/analyze the results?

* 通过表1使用列表展现出与FreeBSD、Linux、Windows等通过硬件保护的进程相比，SIP之间的通信引起的开销更低，并且创建和销毁成本低。列出了一些主流的操作系统，同时有明确的的数字比对，让人感觉很有说服力，
* 通过表5使用柱形图展示的执行时间的对比，而且还列出了增长或降低的百分比，可以更显著的说明实验效果。
* 测试方法的话文中讲的不是太多，我认为测试时要详细记录各方面的数据，以便用于与其它系统的对比。

## How can the research be improved?

这方面感觉Singularity团队很关注新技术的发展，而且还专门总结了过去三年在操作系统设计上产生的新的技术等，并且还把这部分技术应用到了Singularity系统的开发，这是值得学习的。

我觉得要想设计的更好，还是要关注主流技术的前进方向，把握潮流，才能逐渐进步。

同时要多读相关方面的论文。

## If you write this paper, then how would you do?

如果我写的话，会更多的使用比较的手法来写，例如ABI,感觉就是操作系统中的System call,可以将相关概念进行类比，指出新的东西是用来替换原来操作系统中的哪些部分，同时会着重说明原来的实现方式有哪些地方不好，以及现在的实现方式通过什么改变了这些缺点，以及带来了哪些效益等。

同时可能会类比到一些生活中的事，是文章更加生动易懂。

## Did you test the results by yourself? If so,What’s your test Results?

暂时没有尝试，希望后期试验一下这个操作系统。

## Give the survey paper list in the same area of the paper your reading.

本科阶段这方面涉猎较少，该领域知识匮乏。