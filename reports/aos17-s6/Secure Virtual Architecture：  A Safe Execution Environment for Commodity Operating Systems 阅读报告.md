# Secure Virtual Architecture：  A Safe Execution Environment for Commodity Operating Systems 阅读报告

## 1.论文背景

当今商用操作系统（linux、mac OS等）和安全敏感型的应用(openssh)都是用弱类型和需开发者自行管理内存分配释放的C、C++语言写成，因此容易产生数组越界、内存泄漏、悬挂指针等安全性问题，并被攻击者利用。之前的工作都未能较好的解决问题：用安全型语言编写操作系统，能保证内存安全，但性能不高，功能有限；虚拟机、容器只能使系统中的组件隔离，不能提供细粒度的安全保证；基于语言的细粒度安全机制等只能用于某个组件，无法作用于整个系...为了从基础上解决安全问题，作者提出了SVA,它结合了在编译时指令生成和运行时的安全检查，在硬件和整个操作系统间透明地加了一层虚拟层，提供了一个安全的运行环境。

SVA具有以下性质：内存安全，保证控制流一致，对于部分对象能保证类型安全，支持程序的可靠性分析。



## 2.设计架构及创新点

为了减少信任基，从根本上保证安全，作者在硬件和操作系统之间加了一层抽象，在系统指令和系统程序间加了一层自己设计的中间指令集，包括SVA-Core和SVA-OS。当移植一个操作系统时，需像移植到一个新的硬件架构时修改源码中关于于访问硬件的特权指令和维护处理器状态有关的指令的汇编和宏定义，这时会用到SVA-OS。其次还应修改内核内存分配和释放来保证内存安全。SVA-Core主要包括算术、逻辑、分支、判断等指令。

实现

编译：参考了SAFECode来保证细粒度的内存安全，在编译时，通过指针分析将内存分为不同的池metapool，同一metapool内的对象是同类型的，并注册池内对象和其范围，使能运行时的边界检查、类型检查、释放检查等，并计算调用图来保证执行时的路径，生成对应的metadta并嵌入bytecode。

运行时检查：

当加载、运行时，SVA检查bytecode中嵌入的安全检查metadata来判断程序是否满足安全性约束，包括类型检查、边界检查、存取检查、间接调用检查、非法释放检查。

分析精度的提升：

为了提高分析的精度，可以引入额外的源码修改，如标志失败的常数函数返回值，限制函数指针的取值范围等



## 3.实验验证

作者在SVA上移植了linux，测试了一些标准程序的运行时间和处理单宽。SVA引入了不同程度的可以接受的开销，但可以从5个漏洞中检查出4个。



## 4.相关工作

SVA和之前的工作有不同程度上的相似之处

VMware,Xen等hypervisor、VMM是在一个物理上虚拟出多个OS，而SVA是在硬件和OS间加了一层，二者是正交和可以互补的；

用安全型语言（java,modula-3...)等重写的实验性OS由于性能开销和现代OS的庞大，被商用是不现实的，而SVA提供了相较略弱的安全性，但可直接移植完整的商用OS；

采用隔离来提升安全性的工作多数只是针对OS的部分组件的粗粒度隔离，而SVA通过内存安全、编译运行相结合等来保证隔离；

proof-carrying code只能对c语言的子集保证安全性；

Open Kernel Environment 可以定制化的用Cyclone语言拓展内核，但只能实现有限的功能，SafeDrive只能用于驱动程序；

Klee等静态分析的方法可以和SVA结合在运行前排除bug；

TALx86能够在汇编中加入类型性质来提供x86指令的安全性。



