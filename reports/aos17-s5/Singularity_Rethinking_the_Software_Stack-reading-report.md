#  Singularity：Rethinking the Software Stack
------
## Singularity的基本描述
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多研究都指出，现行的大部分系统的设计都是基于二十世纪六七十年代的计算机体系体系结构和编程语言，但是今天的计算环境与四五十年前相比，已经有了相当大的改变。计算速度以及存储空间的局限问题在今天看来都已经不再成为瓶颈，但是与硬件环境的快速进化相比，操作系统的进化速度相当慢，这就导致现在出现了很多的问题。包括:**安全性问题**，**应用程序交互的不可预测性**，**扩展的不安全问题**、**补丁**、**驱动等导致的系统异常**，以及**健壮性问题**，人们开始反思导致系统中普通存在而且愈来愈明显的缺陷的根本原因。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Singularity正是在对操作系统的设计理念的深入思考之下的产物。在Singularity的整个设计过程中，设计者们一直试图去回答这样的问题:如果把可靠性和可信度作为首要的设计目标，从头去设计一个软件平台，它应该是什么样的?为了这个目的，Singularity的设计者们采取了三种策略:
> * 首先，通过安全的编程语言来消除诸如缓冲区溢出这样可以在程序设计语言一级就可以消除的缺陷;
> * 其次，使用可靠的程序验证工具进一步保证排除在开发阶段人为引入的错误;
> * 第三，采用一种更为先进的系统体系结构阻止运行时错误的进一步蔓延，因而得以更容易实现系统的安全和健壮。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Singularity再设计中，提出了三个关键性特征:**软件独立进程**(software-isolated processes, SIP)，**基于Contract的信道**(contract-based channels)，以及**基于Manifest的程序**(manifest-based programs)，来提高软件系统的验证可行性。
>* 软件独立进程提供一个免于外界干扰的程序执行环境;
>* 基于Contract的信道使得进程间进行快速、可验证的消息通信成为可能;
>* 基于Manifest的程序则对软件独立进程所要运行的代码进行精确的定义并且限定了它的所有行为。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这三条不同的基础性特征分别对程序的执行、通信和体系验证予以支持，它们是构建一个可靠且可验证的系统的基石。
###软件独立进程(Software-Isolated Processes)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Singularity的一个基础性特征是软件独立进程(SIP).本质来说，SIP是一个系统资源容器，用于管理系统的软件和资源，但是和传统的操作系统不同，SIP充分地利用了现代编程语言的类型和内存安全性检查特征，极大地降低了隔离安全代码的开销。在singularity的设计哲学中，SIP之间不能共享可写内存；在运行时，SIP内的代码必须是密封的；SIP之间是通过软件验证来进行隔离，而不是通过硬件保护来实现。换句话说，SIP是封闭的对象空间。处在某个SIP协议内的对象是不允许其他SIP修改或直接访问的。SIP之间的通信只能通过转移消息内数据的所有权来实现，而这种所有权是独占性的。因此，SIP以一种自治的方式执行；每个SIP都有其数据层、运行时系统和垃圾收集器。作为一个密封的进程，SIP不能为自身动态加载或生成代码。因此必须为操作系统和应用程序采取一种扩展结构:扩展代码在一个新的进程中执行，与它的宿主SIP独立开来。密封进程提供了很多优势，可以提升用于静态检测缺陷的程序分析工具的能力，可以提供更强壮的安全结构(例如可以通过代码内容来识别一个进程)，也不需要在运行期执行环境中重复系统的访问控制。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SIP之间的隔离依赖于编程语言的类型和内存安全检查，而不是用于内存管理的硬件。通过结合静态验证和运行期检查，Singularity确保某个SIP中的用户代码不会访问该SIP之外的内存区域。使用软件而不是硬件保护机制提供的进程间隔离，使得多个SIP可以驻留在同一个物理空间或虚拟地址空间。这样做的一个好处是可以大大降低进程切换的开销。而且与硬件隔离机制下的进程通信开销相比，SIP之间的通信开销要小得多，另外，进程的创建与销毁开销也相应得到了减小。
### 基于Contract的信道(Contract-Based Channels)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Singularity中，所有SIP之间的通信都必须通过基于Contract的信道进行。信道是一个具有两个端点的双向信息通道。信道能够提供一个无损的、有序的消息队列。一个信道端点在运行时都仅属于一个线程，而每一个信道都对应一个FIFO队列:发送方将消息入队，而接收方将消息提取出队。
信道上的通信使用信道Contract来进行描述。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经验表明，信道通信对预防和发现错误是非常有用的。程序设计人员在起初对这种协议的功能持相当的怀疑态度，协议验证器是在网络协议栈和web服务器完成差不多一年之后才完成的。但是它很快就找出了协议栈和web服务器之间的交互错误，导致这个错误是由于程序员没有考虑到:在一个接入的Socket中没有数据包时需要返回NO_ DATA消息。这个错误在web服务器中已经存在了大约一年之久，验证器很快就发现了这个错误并指出了该错误会被触发的具体情况。
### 基于Manifest的程序(Manifest-Based Programs)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Singularity第三个基础性结构特征是其基于Manifest(清单)的程序(MBP)。 MBP是一种通过静态Manifest进行定义的程序，用来描述MBP的代码资源、所需的系统资源、对其他程序的依赖等。任何一个在Singularity上运行的程序都必须具备一个Manifest。用户在执行一个程序时，实际上是调用其相应的Manifest，而不是像其他系统一样去执行一个文件。当一个MBP安装到系统中之后，Manifest会用来标识并确认MBP代码符合所有系统所需的安全特性，并保证MBP中所有的系统依赖项都可以满足，避免与之前系统中安装过的MBP发生冲突。实际上Manifest并不仅是对程序的描述或SIP代码细节清单，它还是一个对MBP预期行为的描述。通过Manifest可以实现对MBP的静态或者动态的特征验证。例如一个设备驱动程序的Manifest将提供足够的信息以对该驱动进行安装时的验证，以保证该驱动不会去访问其他已安装的驱动正在访问的硬件。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MBP具有极大的灵活性，其代码可以作为清单的内嵌元素，也可以放置在单独的文件中。解释性的脚本语言(例如Singularity shell语言)可以以内嵌元素的形式包含在Manifest内。
### Singularity内核
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为Singularity系统的核心，其内核提供了对其三大基础性特征的支持。作为微内核，Singularity内核提供对SIP、基于Contract的信道以及MBP的基本抽象，在相互竞争的进程之间分配系统资源，同时对复杂的硬件系统进行抽象。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Singularity内核中，所有的设备驱动、网络协议、文件系统和用户可替换的服务都在内核外的SIP中执行。保留在内核中的功能仅包括调度、硬件访问优先级仲裁、管理系统内存、创建销毁SIP和信道。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Singularity总共提供了92个ABI。在Singularity的设计中，AB I遵循最低特权的原则，即赋予ABI以最小可能的特权，从而保证一个安全且隔离的最小执行环境。每个SIP除了操作自身的状态、创建和停止其子SIP之外，不具备其他特权功能。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Singularity采用了交换堆区域的概念，在SIP之间传输的所有数据都驻留于交换堆里，交换堆中的指针只能指向其自身，而在文换堆中的每一块内存区域在任何一个时刻只能是被最多一个SIP所拥有。这一特征可以通过运行时验证器予以验证。Singularity内核和SIP都是多线程程序，所有的线程和内核线程都是对内核调度器可见的，内核调度器负责协调阻塞操作。Singularity内核调度器与传统的调度器的区别体现在针对频繁交换的SIP之间的调度所做的优化通过优化的调度策略，内核调度器可以对那些频繁交换的线程以很小的代价进行调度。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大量的垃圾收集算法都表明：没有任何一个垃圾收集器可以适用于所有的系统和所有的代码。Singularity通过对垃圾收集算法、数据结构的分拆，针对SIP来执行其垃圾收集功能，因此可以根据SIP的行为来选择性地采用垃圾收集器进行垃圾回收。通过这种方式，Singularity可以在有效地保证回收效率的同时，降低全局协议的开销。
## Singularity的设计哲学
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Singularity颠覆了传统的操作系统设计的观念，在Singularity的设计哲学中，包含了一个重要的理念：清晰的设计要比性能更为重要。很多的设计都旨在指供足够好的性能，但是并不追求最好的性能。实际上，Singularity在某些方面的表现，比如SIP之间的通信性能要远远优于现有的操作系统。这完全得益于在Singularity的设计之初就莫定下的三个基本特征。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从Singularity中得到的最大启发是：编程语言、操作系统结构和验证工具之间的紧密反馈和联系。语言和验证工具的选择影响了操作系统的体系结构，而对操作系统体系结构的选择反过来又影响了语言和验证工具。对语言、验证工具以及体系结构的综合考虑所带来的好处，Singularity仅仅体现了其冰山一角，但已展现出未来巨大的潜力。.
## 未来研究工作
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Singularity系统作为一个基本的demo原型，很好的考虑了系统的安全性能，这是值得肯定的，然而只是作为一个demo，在实现完备性上可能还存在一定的欠缺，同时如果部署到真正的商业环境中，也会存在较多的实际应用问题，比如作为基础服务设施，一个很重要的衡量指标就是性能方面：能够应对大规模的复杂计算和系统的切换开销等，都是一个值得进一步探讨的地方。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Singularity设计中，虽然创新性的提出了基于manifest的编程，而且也被认为能够极大的减少系统的开销和提高系统运行的安全，但是只是在理论上进行了分析，在实际的测试中，任然有待进一步的完善。
