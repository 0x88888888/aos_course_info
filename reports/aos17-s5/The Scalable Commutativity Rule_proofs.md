# COMMURE PROOFS
可以通过参考实现M和历史H = X || Y来构建可扩展的实现M以证明交换性的正确性，因为构造的方式是模拟这个参照的全部历史，因此对于任何历史都是正确的。对于任何的一个H=X||P，（P是Y的一个前缀），如果这个实现中，P是不冲突的，因此，整个H都是不冲突的，从而使得基于这样一个交换规则的实例也是可扩展的。

首先介绍一下非扩展的问题：在一个参考的实现中，初始状态以replay开始，当调用顺序能满足H，能正常响应，当调用输入偏离和H时，不知道如何响应，因此进入仿真模式。
这个实现是正确的，它对任何的响应历史始终与参考实现相匹配。但它没有扩展性。在重播模式下，任意两个步骤mns冲突访问s.h.这些访问轨迹能够追踪发生了哪些调用，没有他们的情况下，不可能初始化稍后M状态，这也是交换性的关键所在。

下面构造一个可以扩展的版本：
和Mns类似，但是能够进行无冲突扩展，用于执行Y，包含三个状态：
>* s.h[t]，保存每个线程的历史状态。当某个特殊的COMMUTE交换区域已经开始时初始化为X||COMMUTE||（Y|t）。
>* s.commute[t]，用以标记每个线程标是否到达交换区。始化到FALSE
>* s.refstate 一个参考实例的实现状态。

在交换区域中的每个步骤只能访问特定的调用线程的状态组件。因此交换区域中的任何两个步骤都是无冲突，交流规则得到证明。
在探测到调用信息和参考H不一致时候，在一般情况下，没有信息用以恢复到之前的状态，因此追踪每一个线程的调用状态（s.h [t]组件跟踪了每个线程发生了哪些调用）。因此，调用H'可能会重新排序调用在Y. SIM交换保证replay的H'能够从实际的调用顺序中产生无法区分的结果。
