# RID: Finding Reference Count Bugs with Inconsistent Path Pair Checking

#### Background & Motivations

- 引用计数是操作系统中，同步控制、动态资源管理等内核子系统广泛使用的技术。但同时，其使用不当也极易造成系统Bug。
- 通常，对引用计数器的操作会以封装的API的形式提供给开发人员，这些API的正确使用需要程序员保证，在复杂程序中，这一点是不容易保证的。相关调研表明，由此带来的系统Bug甚至在成熟的Linux内核软件中都是数量众多的一类。因此，引用计数Bug的自动检测机制很有必要。

#### Major Innovations

- 提出了对程序中引用计数Bug的**静态**检查方法，不一致路径检查机制。该方法相比原有工作，使用时约束条件少，仅需要相关API的标准
- 给出了实现上述机制的过程间分析算法以及原型系统

#### Related Work

##### 1. 检测引用计数Bug

- **Referee**: 符号化的模型检查方法，有较多的前提假设：整个程序的控制流信息已知；资源以数组方式被独立管理；所有线程以相同方式管理和使用资源。
- **浅别名静态分析**：在程序入口处将所有资源引用置零，程序退出时检测引用是否为零。对封闭的程序有用，但是对库函数这类开放式的程序不适用。
- **基于规则的Cpychecker和Pungi**：程序中引用计数的改变必须和函数中丢隐的引用数量一致。但是该方法不适用于对基本引用计数接口进行封装的情况。

##### 2. 基于标准进行推断的方法

利用统计分析等方法，根据相关API在大量代码中出现频率的分析，从标准中挖掘API的使用模式。但是现有的工作表明，该方法在从样本中过滤规则时，界限设置的不合理导致大量的API使用规则没有被发现。此外，依据频率来过滤规则，有可能发现不了被经常误用的API。

##### 3. 基于不一致性检测Bug

相关工作对不一致性的定义存在不同，比如使用同一个值时对其不同含义的假设，对同一个值不同类型的引用或者重复出现时不同的句法等。与此不同，RID将不一致性定义为在同一个函数内部的两条不同的执行路径上，引用计数发生了不同的改变，同时运行时该变化在函数外部是不易被察觉的。该类不一致性导致的Bug是原有方法很难发现的，因此是对现有不一致性检测方法的一个很好的补充。